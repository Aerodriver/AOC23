<!doctype html>
<html lang="en">
<head>
	<title>
		AOC 2023 Hohoho
	</title>
	<style>
		body {
			background-color: black;
		}
		h1, h2,button {
			color: crimson;
		}
		p {
			color: aqua;
		}
	</style>
</head>

<body>
<h1>AOC 2023 --- Merry Christmas to all who see this </h1>

<p> 
	This is a "website" for the <a href="https://adventofcode.com/2023">AOC</a> and also a) a logbook of how I went mad and b) something for me to easily test other people inputs after I solved the daily task.
</p>
<p>
	The code for this website and my attempts at writing Typescript can be found at the <a href="https://github.com/Aerodriver/AOC23/tree/master">git repository</a>.
</p>

<h2> Day 1</h2>
<p>
	First day of AOC, first day of trying out Typescript. 
	After getting things to run locally and wrestling with the question "are those additions or string concats that I am doing?", part 1 was easy.
	Then Part 2 put me in a temporary stasis.
	Because my initial solution was based on a regular expression I had to do some thinking.
	Now some of the words I was looking for could overlap and normally regex consumes the matches, so that overlapping numbers would not be detected.
	I resorted to using lookaheads and only match the parts that can't be part of an overlap, resulting in matches like "nin".
	While not great, it worked and Day 1 ended without me murdering someone.
</p>
<p>Please insert a text file below to get the (hopefully correct) results</p>
<input type="file" name="inputfile" id="inputd1.1"/>
<p id="outd1.1"> Result for Part 1  will appear here</p>
<p id="outd1.2"> Result for Part 2 will appear here</p>

<script id="Day1" defer>

	const inputElement1 = document.getElementById("inputd1.1");
	const outputElement1 = document.getElementById("outd1.1");
	const outputElement2 = document.getElementById("outd1.2");

	inputElement1.addEventListener("change", solver2Day1, false);
	function solver2Day1() {
		let reader = new FileReader();
		reader.onload = function () {
			const arr = reader.result.split(/\r?\n/);
			let numbers  = []
			arr.forEach((line) => {
				numbers.push(filterNumsFromLine(line))
			});
			outputElement1.textContent = numbers.reduce( (accumulator, curr) => Number(accumulator) + Number(curr));
			numbers  = []
			arr.forEach((line) => {
				numbers.push(filterNumsFromLine2(line))
			});
			outputElement2.textContent = numbers.reduce( (accumulator, curr) => Number(accumulator) + Number(curr));

            }
			reader.readAsText(this.files[0]);
	}

	/*****************************************************************************/
	const filterNumsFromLine = (line) => {
		const numbers = line.matchAll(/[0-9]/g);
		const first = numbers.next().value
		const last = [...Array.from(numbers)].pop()
		if( first == 0){
			console.log(line)
		}
		if(last === undefined){
			return first+first
		}
		else {
			return first+last
		}
	};
	//Stuff for part 2
	const filterNumsFromLine2 = (line) => {
		const numbers = line.matchAll(/[0-9]|on(?=e)|tw(?=o)|thr(?=ee)|four|fi(?=ve)|six|sev(?=en)|eigh(?=t)|ni(?=ne)/g);
		const nameToNum = {"on":"1", "tw":"2", "thr":"3", "four":"4", "fi":"5", "six":"6", "sev":"7", "eigh":"8", "ni":"9"} 

		const test = numbers.next().value
		const first = (test[0] in nameToNum)? nameToNum[test[0]] : test[0];
		const last = [...numbers].pop()
		
		if(last === undefined){
			return Number(first + first)
		}
		else {
			const reallast = (last[0] in nameToNum)? nameToNum[last[0]] : last[0];
			return Number(first + reallast)
		}
	};
</script>
</br>

<h2> Day 2 </h2>
<p>
	Second Day.
	If I find the time I will make this website work as something more than just a worse logbook; if I don't then I will just keep writing about my descent into madness induced by Typescript
	So while getting Typescript stuff to automaticly be put into here did not work out without havning to put thought into it, I decided to simply put the equivalent JavaScript as script tags in here.
	Now this html file can be used standalone without a server or whatnot.
</p>
<p>
	This day was way easier than day 1, so I got to look at how classes work (at a basic level, polymorphism might come in play in the future) and even use a custom type.
	I am still handling parsing with regex and dread the day where this won't be enough for a task.
	The first part took me the longest (the second was just "search for the max number in a game for every color") because I did not read the task right and initially used a wrong regex for parsing (did not account for double digits xD).
	So far this is more an intro to JS than an intro to TS, but we will se where the journey goes.
</p>
<p>Please insert a text file below to get the (hopefully correct) results</p>
<input type="file" id="inputd2.1"/>
<p id="outd2.1"> Result for Part 1  will appear here</p>
<p id="outd2.2"> Result for Part 2 will appear here</p>

<script id="Day2" >
	const inputElementd2 = document.getElementById("inputd2.1");
	const outputElementd2p1 = document.getElementById("outd2.1");
	const outputElementd2p2 = document.getElementById("outd2.2");

	inputElementd2.addEventListener("change", eventListenerDay2, false);
	function eventListenerDay2() {
		let reader = new FileReader();
		reader.onload = function () {
			const arr = reader.result.split(/\r?\n/);
			outputElementd2p1.textContent = solve1(arr);
			outputElementd2p2.textContent = solve2(arr);
		}
		reader.readAsText(this.files[0]);
	}
	/*****************************************************************************/
	class Game {
		id;
		bagSequence;

		constructor(id=0) {
			this.id = id
			this.bagSequence=[]
		}

		addBagFromString(bagString){
			const reg=(/\d+\sgreen|\d+\sred|\d+\sblue/g);
			let newbag = {
				blues:0,
				greens:0,
				reds:0
			}

			for (let found of bagString.matchAll(reg)){
				const currval = found[0]
				const stuff = currval.split(/\s/)
				switch(stuff[1]){
					case "green":
						newbag.greens=Number(stuff[0]);
						continue;
					case "red":
						newbag.reds=Number(stuff[0]);
						continue;
					case "blue":
						newbag.blues=Number(stuff[0]);
						continue;
				}
			}
			this.bagSequence.push(newbag)
		}

		addBag(bag){
			this.bagSequence.push(bag)
		}

		findIfNoViolation(reds,greens,blues){
			for (let bag of this.bagSequence){
				if ( bag.reds>reds || bag.greens>greens || bag.blues>blues){
					return 0
				}
			}
			return this.id
		}

		findSmallestNeededCube(){
			let mingreen=0
			let minred=0
			let minblue=0
			for (let bag of this.bagSequence){
				mingreen = mingreen<bag.greens? bag.greens: mingreen;
				minred = minred<bag.reds? bag.reds: minred;
				minblue = minblue<bag.blues? bag.blues: minblue;
			}
			return [mingreen,minblue,minred]
		}
	} 

	const buildAGame = (line, id=0) => {
		let g = new Game(id);
		line.split(/:/)[1].trim().split(/;/).forEach((round)=>{
			g.addBagFromString(round.trim())
		})
		return g
	}
	
	function solve1(contents){
		let count=1;
		let acc=0;
		contents.forEach(
			(line) => {
				let g = buildAGame(line, count)
				acc = acc + g.findIfNoViolation(12,13,14)
				count = count+1
			}
		)
		return acc
	}

	function solve2(contents){
		let acc=0
		contents.forEach(
			(line) => {
				let g = buildAGame(line)
				acc = acc + g.findSmallestNeededCube().reduce((prev, curr) => prev*curr)
			}
		)
		return acc
	}
</script>
</br>

<h2> Day 3 </h2>
<p>
	I tried using type aliases and made many mistakes like expecting a Map to be capable of taking more than just one simple value as a key (for example a pair of two numbers).
	My first idea was to scan the lines in a very stupid way, what I came up with later is not much more intelligent but it is shorter.
	It feels like not using type aliases would have made things easier; also my python "everything has to be done functionally and on a list" mentality keeps haunting me.
	I still did not look into automatically putting the finished Javscript in here so copy and paste has to be enough.
	My biggest fear right now is that I did not see some edge case where my code would break however as it gave me the correct results, I am somewhat optimistic.
	One thing which thankfully wasn't a problem, where numbers that had two gears connect them, but I still think that my code might take a number more than once in some case.
	Scratch that last sentence the possible bug of one number being taken into account more than once for part 1, was fixed.
</p>

<p>Please insert a text file below to get the (hopefully correct) results</p>
<input type="file" id="inputd3.1"/>
<p id="outd3.1"> Result for Part 1  will appear here</p>
<p id="outd3.2"> Result for Part 2 will appear here</p>

<script id="Day3" defer>
	const inputElementd3 = document.getElementById("inputd3.1");
	const outputElementd3p1 = document.getElementById("outd3.1");
	const outputElementd3p2 = document.getElementById("outd3.2");

	inputElementd3.addEventListener("change", eventListenerDay3, false);
	function eventListenerDay3() {
		let reader = new FileReader();
		reader.onload = function () {
			const arr = reader.result.split(/\r?\n/);
			outputElementd3p1.textContent = solverd3p1(arr);
			outputElementd3p2.textContent = solverd3p2(arr);
		}
		reader.readAsText(this.files[0]);
	}
	/*****************************************************************************/


	const input = "day3-input.txt";
	const testinput = "day3-test.txt";
	function elemToNumpos(elem) {
		return { actualNum: Number(elem[0]), begin: Number(elem["index"]), end: Number(elem["index"]) + elem[0].length - 1 };
	}
	function solverd3p1(lines) {
		let numsPos = new Set();
		const regNum = /\d+/g;
		const regSym = /[^\d\.]/g;
		for (let linenumber = 1; linenumber < lines.length; linenumber = linenumber + 1) {
			const scan1 = lines[linenumber - 1];
			const scan2 = lines[linenumber];
			const nums1 = [...scan1.matchAll(regNum)].map((elem) => { return elemToNumpos(elem); });
			const syms1 = [...scan1.matchAll(regSym)].map((elem) => { return { position: Number(elem["index"]) }; });
			const nums2 = [...scan2.matchAll(regNum)].map((elem) => { return elemToNumpos(elem); });
			const syms2 = [...scan2.matchAll(regSym)].map((elem) => { return { position: Number(elem["index"]) }; });
			syms1.forEach((sp) => {
				for (let num of nums2) {
					if (sp.position >= num.begin - 1 && sp.position <= num.end + 1) {
						numsPos.add({ linenum: linenumber, linepositions: num });
					}
				}
				for (let num of nums1) {
					if (sp.position == num.end + 1 || sp.position == num.begin - 1) {
						numsPos.add({ linenum: linenumber - 1, linepositions: num });
					}
				}
			});
			syms2.forEach((sp) => {
				for (let num of nums1) {
					if (sp.position >= num.begin - 1 && sp.position <= num.end + 1) {
						numsPos.add({ linenum: linenumber - 1, linepositions: num });
					}
				}
			});
		}
		return [...new Set([...numsPos]
				.map((item) => item.linepositions.actualNum + "|" + item.linenum + "|" + item.linepositions.begin + "|" + item.linepositions.end))]
			.map((str) => Number(str.match(/\d+/)))
			.reduce((a, b) => a + b);
	}
	function solverd3p2(lines) {
		let numsPos = new Set();
		const regNum = /\d+/g;
		const regGear = /\*/g;
		for (let linenumber = 1; linenumber < lines.length; linenumber = linenumber + 1) {
			const scan1 = lines[linenumber - 1];
			const scan2 = lines[linenumber];
			const nums1 = [...scan1.matchAll(regNum)].map((elem) => { return elemToNumpos(elem); });
			const gear1 = [...scan1.matchAll(regGear)].map((elem) => { return { gearposition: Number(elem["index"]), gearlinenum: linenumber - 1 }; });
			const nums2 = [...scan2.matchAll(regNum)].map((elem) => { return elemToNumpos(elem); });
			const gear2 = [...scan2.matchAll(regGear)].map((elem) => { return { gearposition: Number(elem["index"]), gearlinenum: linenumber }; });
			gear1.forEach((sp) => {
				for (let num of nums2) {
					if (sp.gearposition >= num.begin - 1 && sp.gearposition <= num.end + 1) {
						numsPos.add({ linenum: linenumber, linepositions: Object.assign(Object.assign({}, num), sp) });
					}
				}
				for (let num of nums1) {
					if (sp.gearposition == num.end + 1 || sp.gearposition == num.begin - 1) {
						numsPos.add({ linenum: linenumber - 1, linepositions: Object.assign(Object.assign({}, num), sp) });
					}
				}
			});
			gear2.forEach((sp) => {
				for (let num of nums1) {
					if (sp.gearposition >= num.begin - 1 && sp.gearposition <= num.end + 1) {
						numsPos.add({ linenum: linenumber - 1, linepositions: Object.assign(Object.assign({}, num), sp) });
					}
				}
			});
		}
		let gearmap = new Map();
		const bullshit = (a, b) => { return a + '|' + b; };
		for (let l of [...numsPos]) {
			const key = bullshit(l.linepositions.gearlinenum, l.linepositions.gearposition);
			if (gearmap.has(key)) {
				gearmap.get(key).push(l.linepositions.actualNum);
			}
			else {
				gearmap.set(key, [l.linepositions.actualNum]);
			}
		}
		return [...gearmap].map((el) => el[1].length == 2 ? el[1].reduce((a, b) => a * b) : 0).reduce((a, b) => a + b);
	}
</script>

<br/>
<h2> Day 4 </h2>
<p>
	Probably the easiest day so far. 
	If it where not for my inability to get the correct indexes in Part 2 this would have taken less time than it did.
	I also startet to add some dumb versions for things like a map or a set; they internally just use a map or set where things are stringified but with this I can use them in the future without having to think about stuff like Set(2) {[name,1], [name,1]} again.
	Only thing that gives me a headache at the moment are iterables in those dumb classes but so far it seems to work(?).
</p>

<p>Please insert a text file below to get the (hopefully correct) results</p>
<input type="file" id="inputd4.1"/>
<p id="outd4.1"> Result for Part 1  will appear here</p>
<p id="outd4.2"> Result for Part 2 will appear here</p>

<script id="Day4" defer>
	const inputElementd4 = document.getElementById("inputd4.1");
	const outputElementd4p1 = document.getElementById("outd4.1");
	const outputElementd4p2 = document.getElementById("outd4.2");

	inputElementd4.addEventListener("change", eventListenerDay4, false);
	function eventListenerDay4() {
		let reader = new FileReader();
		reader.onload = function () {
			const arr = reader.result.split(/\r?\n/);
			outputElementd4p1.textContent = solverd4p1(arr);
			outputElementd4p2.textContent = solverd4p2(arr);
		}
		reader.readAsText(this.files[0]);
	}
	/*****************************************************************************/

	function numberOfWinningNumbers(line) {
		var _a;
		const reg = /(?<winnums>(\d+|\s)+)\|(?<mynums>(\d+|\s)+)/;
		const numreg = /\d+/g;
		let groups = (_a = line.match(reg)) === null || _a === void 0 ? void 0 : _a.groups;
		if (groups) {
			const win = new Set([...groups["winnums"].matchAll(numreg)].map((e) => Number(e)));
			const my = new Set([...groups["mynums"].matchAll(numreg)].map((e) => Number(e)));
			return (([...win].filter(x => my.has(x)).length));
		}
		return 0;
	}
	function solverd4p1(lines) {
		const pointCalc = (num) => num > 0 ? Math.pow(2, num - 1) : 0;
		const points = [];
		for (let line of lines) {
			points.push(numberOfWinningNumbers(line));
		}
		return points.reduce((acc, curr) => acc + pointCalc(curr), 0);
	}
	function solverd4p2(lines) {
		const card_repeat = new Map();
		for (let e of lines.entries()) {
			if (!card_repeat.has(e[0])) {
				card_repeat.set(e[0], 1);
			}
			const how_often_to_count_card = card_repeat.get(e[0]);
			const numofwinnum = numberOfWinningNumbers(e[1]);
			for (let i of [...Array(numofwinnum).keys()]) {
				if (card_repeat.has(e[0] + i + 1)) {
					card_repeat.set(e[0] + i + 1, card_repeat.get(e[0] + i + 1) + how_often_to_count_card);
				}
				else {
					card_repeat.set(e[0] + i + 1, how_often_to_count_card + 1);
				}
			}
		}
		return [...card_repeat.values()].reduce((a, b) => a + b);
	}
</script>

</body>
</html>