<!doctype html>
<html lang="en">
<head>
	<title>
		AOC 2023 Hohoho
	</title>
	<style>
		body {
			background-color: black;
		}
		h1, h2,button {
			color: crimson;
		}
		p {
			color: aqua;
		}
	</style>
</head>

<body>
<h1>AOC 2023 --- Merry Christmas to all who see this </h1>

<p> This is a "website" for the <a href="https://adventofcode.com/2023">AOC</a> and also a) a logbook of how I went mad and b) something for me to easily test other people inputs after I solved the daily task.</p>
<p>The code for this website and my attempts at writing Typescript can be found at the <a href="https://github.com/Aerodriver/AOC23/tree/master">git repository</a>.</p>

<h2> Day 1</h2>
<p>
	First day of AOC, first day of trying out Typescript. 
	After getting things to run locally and wrestling with the question "are those additions or string concats that I am doing?", part 1 was easy.
	Then Part 2 put me in a temporary stasis.
	Because my initial solution was based on a regular expression I had to do some thinking.
	Now some of the words I was looking for could overlap and normally regex consumes the matches, so that overlapping numbers would not be detected.
	I resorted to using lookaheads and only match the parts that can't be part of an overlap, resulting in matches like "nin".
	While not great, it worked and Day 1 ended without me murdering someone.
</p>
<p>Please insert a text file below to get the (hopefully correct) results</p>
<input type="file" name="inputfile" id="inputd1.1"/>
<p id="outd1.1"> Result for Part 1  will appear here</p>
<p id="outd1.2"> Result for Part 2 will appear here</p>

<script id="Day1" defer>

	const inputElement1 = document.getElementById("inputd1.1");
	const outputElement1 = document.getElementById("outd1.1");
	const outputElement2 = document.getElementById("outd1.2");

	inputElement1.addEventListener("change", solver2Day1, false);
	function solver2Day1() {
		let reader = new FileReader();
		reader.onload = function () {
			const arr = reader.result.split(/\r?\n/);
			let numbers  = []
			arr.forEach((line) => {
				numbers.push(filterNumsFromLine2(line))
			});
			outputElement2.textContent = numbers.reduce( (accumulator, curr) => Number(accumulator) + Number(curr));
            }
			reader.readAsText(this.files[0]);
	}

	inputElement1.addEventListener("change", solver1Day1, false);
	function solver1Day1() {
		let reader = new FileReader();
		reader.onload = function () {
			const arr = reader.result.split(/\r?\n/);
			let numbers  = []
			arr.forEach((line) => {
				numbers.push(filterNumsFromLine(line))
			});
			outputElement1.textContent = numbers.reduce( (accumulator, curr) => Number(accumulator) + Number(curr));
            }
			reader.readAsText(this.files[0]);
	}

	/*****************************************************************************/
	const filterNumsFromLine = (line) => {
		const numbers = line.matchAll(/[0-9]/g);
		const first = numbers.next().value
		const last = [...Array.from(numbers)].pop()
		if( first == 0){
			console.log(line)
		}
		if(last === undefined){
			return first+first
		}
		else {
			return first+last
		}
	};
	//Stuff for part 2
	const filterNumsFromLine2 = (line) => {
		const numbers = line.matchAll(/[0-9]|on(?=e)|tw(?=o)|thr(?=ee)|four|fi(?=ve)|six|sev(?=en)|eigh(?=t)|ni(?=ne)/g);
		const nameToNum = {"on":"1", "tw":"2", "thr":"3", "four":"4", "fi":"5", "six":"6", "sev":"7", "eigh":"8", "ni":"9"} 

		const test = numbers.next().value
		const first = (test[0] in nameToNum)? nameToNum[test[0]] : test[0];
		const last = [...numbers].pop()
		
		if(last === undefined){
			return Number(first + first)
		}
		else {
			const reallast = (last[0] in nameToNum)? nameToNum[last[0]] : last[0];
			return Number(first + reallast)
		}
	};
</script>
</br>

<h2> Day 2 </h2>
<p>
	Second Day.
	If I find the time I will make this website work as something more than just a worse logbook; if I don't then I will just keep writing about my descent into madness induced by Typescript
	So while getting Typescript stuff to automaticly be put into here did not work out without havning to put thought into it, I decided to simply put the equivalent JavaScript as script tags in here.
	Now this html file can be used standalone without a server or whatnot.
</p>
<p>
	This day was way easier than day 1, so I got to look at how classes work (at a basic level, polymorphism might come in play in the future) and even use a custom type.
	I am still handling parsing with regex and dread the day where this won't be enough for a task.
	The first part took me the longest (the second was just "search for the max number in a game for every color") because I did not read the task right and initially used a wrong regex for parsing (did not account for double digits xD).
	So far this is more an intro to JS than an intro to TS, but we will se where the journey goes.
</p>
<p>Please insert a text file below to get the (hopefully correct) results</p>
<input type="file" id="inputd2.1"/>
<p id="outd2.1"> Result for Part 1  will appear here</p>
<p id="outd2.2"> Result for Part 2 will appear here</p>

<script id="Day2" >
	const inputElementd2 = document.getElementById("inputd2.1");
	const outputElementd2p1 = document.getElementById("outd2.1");
	const outputElementd2p2 = document.getElementById("outd2.2");

	inputElementd2.addEventListener("change", eventListenerDay2, false);
	function eventListenerDay2() {
		let reader = new FileReader();
		reader.onload = function () {
			const arr = reader.result.split(/\r?\n/);
			outputElementd2p1.textContent = solve1(arr);
			outputElementd2p2.textContent = solve2(arr);
		}
		reader.readAsText(this.files[0]);
	}
	/*****************************************************************************/
	class Game {
		id;
		bagSequence;

		constructor(id=0) {
			this.id = id
			this.bagSequence=[]
		}

		addBagFromString(bagString){
			const reg=(/\d+\sgreen|\d+\sred|\d+\sblue/g);
			let newbag = {
				blues:0,
				greens:0,
				reds:0
			}

			for (let found of bagString.matchAll(reg)){
				const currval = found[0]
				const stuff = currval.split(/\s/)
				switch(stuff[1]){
					case "green":
						newbag.greens=Number(stuff[0]);
						continue;
					case "red":
						newbag.reds=Number(stuff[0]);
						continue;
					case "blue":
						newbag.blues=Number(stuff[0]);
						continue;
				}
			}
			this.bagSequence.push(newbag)
		}

		addBag(bag){
			this.bagSequence.push(bag)
		}

		findIfNoViolation(reds,greens,blues){
			for (let bag of this.bagSequence){
				if ( bag.reds>reds || bag.greens>greens || bag.blues>blues){
					return 0
				}
			}
			return this.id
		}

		findSmallestNeededCube(){
			let mingreen=0
			let minred=0
			let minblue=0
			for (let bag of this.bagSequence){
				mingreen = mingreen<bag.greens? bag.greens: mingreen;
				minred = minred<bag.reds? bag.reds: minred;
				minblue = minblue<bag.blues? bag.blues: minblue;
			}
			return [mingreen,minblue,minred]
		}
	} 

	const buildAGame = (line, id=0) => {
		let g = new Game(id);
		line.split(/:/)[1].trim().split(/;/).forEach((round)=>{
			g.addBagFromString(round.trim())
		})
		return g
	}
	
	function solve1(contents){
		let count=1;
		let acc=0;
		contents.forEach(
			(line) => {
				let g = buildAGame(line, count)
				acc = acc + g.findIfNoViolation(12,13,14)
				count = count+1
			}
		)
		return acc
	}

	function solve2(contents){
		let acc=0
		contents.forEach(
			(line) => {
				let g = buildAGame(line)
				acc = acc + g.findSmallestNeededCube().reduce((prev, curr) => prev*curr)
			}
		)
		return acc
	}
</script>
</br>

<h2> Day 3 </h2>

</body>
</html>